<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /* 
### 前端性能优化

#### 1. 减少HTTP的请求次数和传输报文的大小

- 把页面中的CSS/JS等文件进行合并压缩
  - 合并：争取CSS和JS都只导入一个（webpack可以实现自动合并压缩）
  - 压缩：基于webpack可以压缩、对于图片自己找工具先压缩、还可以使用服务器的GZIP压缩
- 雪碧图（精灵图） css sprite

- 尽量使用字体图标（icon font）或者SVG等矢量图
  - 减少HTTP请求次数或者减少请求内容的大小
  - 渲染更快：因为他们是基于代码渲染的，而对于位图（png、jpg、gif）是需要先把图片编码再渲染
  - 不容易失真变形
  - 也可以使用webp格式图片，这种格式要小一些（但是需要服务器端支持这种格式的请求处理）
- 图片懒加载（延迟加载）
  - 第一次加载页面的时候不去请求真实的图片，提高第一次渲染页面的速度
  - 当页面加载完把出现在用户视野区域中的图片做真实加载，没有出现的先不加载（能够节约用户的流量，也能减少对服务器的请求压力）
  - 对于数据我们也尽可能分批加载（不要一次请求过多的数据，例如分页技术）
- 音视频取消预加载（preload='none')，这样可以增加第一次渲染页面的速度，当需要播放的时候再加载

- 客户端和服务器端的数据传输尽可能基于JSON格式来完成，XML格式比JSON格式要大一点（还可以基于二进制编码或者文件流格式，这种格式比文件传输好很多）
- 图片地图：对于多次调取使用的图片（尤其是背景图），我们尽可能把它提取成为公共的样式，而不是每一次重新设置background
- 图片base64（用base64码代表图片，减少HTTP请求，增加了浏览器渲染的速度，所以真实项目中，尤其是移动端，如果图片加载缓慢，可能base64一下就好了，但是，base64会导致文件中的代码超级恶心，不利于维护和开发，所以少使用，webpack可以配置图片的base64）

#### 2. 设置各种缓存、预处理和长连接机制

- DNS缓存或者预处理（DNS PREFETCH)，减少DNS的查找
- 把不经常更改的静态资源做缓存处理（一般做的是304或者是etag等协商缓存）
- 建立HTTP请求中的Cache-Control和Expires HTTP的强缓存（chche-control：no-cache(不走强缓存走协商缓存)/no-store(不走缓存)

- 设置本地的离线存储（manifest）或者把一些不经常更改的数据做本地临时存储（webstorgae、indexdb）
- 有钱就做CDN（地域分布式服务器），还有一个财大气粗的方式：加服务器
- 建立connection:keep-alive TCP长连接
- 使用HTTP2版本协议（现在用的一般是HTTP1.1）
  - 可以多条TCP通道共存 = > 管道化链接
- 一个项目分为不同的域（不同的服务器），例如：资源web服务器、数据服务器、图片服务器、视频服务器等，这样合理利用服务器资源，但是导致过多的DNS解析

#### 3. 代码方面的性能优化

- 减少直接对DOM的操作（原因是减少DOM的重绘和回流），当代项目基本上都是基于MVVM/MVC数据驱动视图渲染的，对DOM的操作框架本身完成，性能要好很多

- 对于动画来说：能用CSS解决的不用JS（能够用transform处理的，不用传统的CSS样式，因为transform开启硬件加速，不会引发回流，再或者使用定位的元素也会好很多，因为定位的元素脱离文档流，不会对其它元素的位置造成影响），能用requestAnimationFrame解决的不用定时器
  - requestAnimationFrame还有一个好处，当页面处于休眠无访问状态，动画会自己暂停，直到恢复访问才开始，而定时器是不论什么状态，只要页面不管，就一直处理
- 避免使用iframe（因为iframe会嵌入其它页面，这样父页面渲染的时候，还有同时把子页面也渲染了，渲染进度会变慢

- 尽可能使用事件委托
- 避免出现死循环或者嵌套循环（嵌套循环会成倍增加循环的次数）
- 低耦合高内聚   尽可能实现JS的封装：方法封装、插件、组件、框架、类库等封装，减少页面中的冗余代码，提高代码使用率
- 项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于PROMISE设计模式来管理）
- JS中不要使用with

- 尽量减少CSS表达式的使用(expression)
- 函数的防抖和节流
- 减少filter滤镜的使用
- 尽可能减少选择器的层级(选择器是从右向左解析) .box a{}和a{}  第二个性能好
- 尽可能减少table布局
- 手动回收堆栈内存（赋值为null）
- 减少使用eval（主要原因是 防止压缩代码的时候，由于符号书写不合规，导致代码混乱）
- 在JS中尽量减少闭包的使用（因为过多使用闭包会产生很多不销毁的内存，处理不好的话，会导致内存溢出“栈溢出”），减少闭包的嵌套（减少作用域链的查找层级）
*/
    //栈溢出:死递归
    function func() {
        func();
    }
    func();

    //解决方案
    function func() {
        setTimeout(func, 0);
    }
    func();

    //相互引用：引用类型之间的相互调用，形成嵌套式内存（高程三）
    let obj1 = {
        name: 'OBJ1'
    }
    let obj2 = {
        name: 'OBJ2',
        x: obj1
    }
    obj1.x = obj2;
</script>