### 前端性能优化

#### 1. 减少 HTTP 的请求次数和传输报文的大小

- CSS SPRITE（雪碧图、图片精灵）技术
- 使用字体图标（ICON FONT）或者 SVG 等矢量图 + 减少 HTTP 请求次数或者减少请求内容的大小 + 渲染更快：因为他们是基于代码渲染的，而对于位图（png/jpg/gif）是需要先把图片编码再渲染 + 不容易失真变形 + 也可以使用 webp 格式图片，这种格式要小一些（但是需要服务器端支持这种格式的请求处理）
- 图片懒加载（延迟加载）技术 + 第一次加载页面的时候不去请求真实的图片，提高第一次渲染页面的速度 + 当页面加载完，把出现在用户视野区域中的图片做真实加载，没有出现的先不加载（节约流量，也能减少对服务器的请求压力） + 对于数据我们也尽可能分批加载（不要一次请求过多的数据，例如分页技术）
- 音视频文件取消预加载（preload='none'），这样可以增加第一次渲染页面的速度，当需要播放的时候再加载
- 客户端和服务器端的数据传输尽可能基于 JSON 格式完成，XML 格式比 JSON 格式要大一些（还可以基于二进制编码或者文件流格式，这种格式比文件传输好很多）
- 把页面中的 CSS/JS/图片等文件进行合并压缩 + 合并：争取 CSS 和 JS 都只导入一个（webpack 可以实现自动合并压缩） + 压缩：基于 webpack 可以压缩、对于图片自己找工具先压缩、还可以使用服务器的 GZIP 压缩
- 图片地图：对于多次调取使用的图片（尤其是背景图），我们尽可能把它提取成为公共的样式，而不是每一次重新设置 background
- 图片 BASE64（用 BASE64 码代表图片，减少 HTTP 请求，增加浏览器渲染的速度，所以真实项目中，尤其是移动端，如果图片加载缓慢，可能 BASE64 一下就好了；但是，BASE64 会导致文件中的代码超级恶心，不利于维护和开发，所以少使用；webpack 中可以配置图片的 BASE64；）

#### 2. 设置各种缓存、预处理和长连接机制

- 把不经常更改的静态资源做缓存处理（一般做的是 304 或者 ETAG 等协商缓存）
- 建立 Cache-Control 和 Expires HTTP 的强缓存
- DNS 缓存或者预处理（DNS PREFETCH），减少 DNS 的查找
- 设置本地的离线存储（manifest）或者把一些不经常更改的数据做本地存储（webstorage、indexdb）等
- 有钱就做 CDN（地域分布式服务器），还有一个财大气粗的方式：加服务器
- 建立 Connection:keep-alive TCP 长连接
- 使用 HTTP2 版本协议（现在用的一般都是 HTTP1.1） + 可以多条 TCP 通道共存 =>管道化链接 + 思考题：HTTP VS HTTPS + 思考题：HTTP1 VS HTTP2
- 一个项目分为不同的域（不同的服务器），例如：资源 WEB 服务器、数据服务器、图片服务器、视频服务器等，这样合理利用服务器资源，但是导致过多的 DNS 解析

#### 3. 代码方面的性能优化

- 减少对闭包的使用（因为过多使用闭包会产生很多不销毁的内存，处理不好的话，会导致内存溢出“栈溢出”），减少闭包的嵌套（减少作用域链的查找层级）
- 对于动画来说：能用 CSS 解决的不用 JS（能够用 transform 处理的，不用传统的 css 样式，因为 transform 开启硬件加速，不会引发回流，再或者使用定位的元素也会好很多，因为定位的元素脱离文档流，不会对其它元素的位置造成影响），能用 requestAnimationFrame 解决的不用定时器 + requestAnimationFrame 还有一个好处，当页面处于休眠无访问状态，动画会自己暂停，直到恢复访问才开始，而定时器是不论什么状态，只要页面不管，就一直处理
- 避免使用 iframe（因为 iframe 会嵌入其它页面，这样父页面渲染的时候，还要同时把子页面也渲染了，渲染进度会变慢）
- 减少直接对 DOM 的操作（原因是减少 DOM 的回流和重绘...），当代项目基本上都是基于 mvvm/mvc 数据驱动视图渲染的，对 DOM 的操作框架本身完成，性能要好很多
- 低耦合高内聚（基于封装的方式：方法封装、插件、组件、框架、类库等封装，减少页面中的冗余代码，提高代码使用率）
- 尽可能使用事件委托
- 避免出现死循环或者嵌套循环（嵌套循环会成倍增加循环的次数）
- 项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于 PROMISE 设计模式来管理）
- JS 中不要使用 with
- 避免使用 CSS 表达式
- 函数的防抖和节流
- 减少使用 eval（主要原因是防止压缩代码的时候，由于符号书写不合规，导致代码混乱）
- 减少 filter 滤镜的使用
- 尽可能减少选择器的层级（选择器是从右向左解析） .box a{} 和 a{}
- 尽可能减少 TABLE 布局
- 手动回收堆栈内存（赋值为 null）

JS 前端代码优化的 108 条建议
雅虎 CSS 代码优化的 36 条建议

webpack 的性能优化
安全优化

```
//=>栈溢出：死递归
function func(){
	func();
}
func();
//=>解决方案
function func(){
	setTimeout(func,0);
}
func();

//=>相互引用：引用类型之间的相互调用，形成嵌套式内存 （高程三）
let obj1={
	name:'OBJ1'
};
let obj2={
	name:'OBJ2',
	x:obj1
};
obj1.x=obj2;
```

### 什么是 AJAX

> async javascript and xml：异步的 JS 和 XML

- 此处的异步指的是：局部刷新（对应的是全局刷新）
- XML：可扩展的标记语言，用自己自定义的标签来存储数据的（在很早以前，我们基于 AJAX 和服务器进行交互的数据格式一般都已 XML 格式为主，因为它能清晰展示出对应的数据和结构层级；但是到后面，流行了一种新的数据格式 JSON，它不仅比 XML 更清晰展示数据的结构，而且同样的数据存储，JSON 更加轻量，也方便解析和相关的操作，所以现在前后端的数据交互都已 JSON 格式为主）


### AJAX的基础操作
```
//1.创建AJAX实例
let xhr=new XMLHttpRequest; //=>IE低版本浏览器中用的是 new ActiveXObject() 高程三中JS惰性编程思想，关于XHR的兼容处理

//2.打开URL（配置发送请求的信息）
//METHOD:HTTP请求方式
//URL:请求地址（API接口地址）
//ASYNC:设置同步或者异步，默认是TRUE异步，FALSE同步
//USER-NAME:传递给服务器的用户名
//USER-PASS:传递给服务器的密码
xhr.open('GET','./json/xxx.json',true);

//3.监听AJAX状态，在状态为X的时候，获取服务器响应的内容
//AJAX状态码：0 1 2 3 4
xhr.onreadystatechange=function(){
	if(xhr.readyState===4 && /^(2|3)\d{2}$/.test(xhr.status)){
		let result = xhr.responseText;
	}
}

//4.发送请求
//SEND中放的是请求主体的内容
xhr.send(null);

=>AJAX任务（发送一个请求给服务器，从服务器获取到对应的内容）从SEND后开始，到XHR.READYSTATE===4的时候算任务结束
```

### HTTP的请求方式
- GET系列请求
	+ GET
	+ DELETE 一般应用于告诉服务器，从服务器上删除点东西
	+ HEAD 只想获取响应头内容，告诉服务器响应主体内容不要了
	+ OPTIONS 试探性请求，发个请求给服务器，看看服务器能不能接收到，能不能返回
- POST系列请求
	+ POST
	+ PUT 和DELETE对应，一般是想让服务器把我传递的信息存储到服务器上（一般应用于文件和大型数据内容）

=>真实项目中用对应的请求方式，会使请求变的更加明确（语义化），不遵循这些方式也可以，最起码浏览器在语法上是允许的；但是这些是开发者们相互间约定俗成的规范；

GET系列一般用于从服务器获取信息，POST系列一般用于给服务器推送信息，但是不论GET和POST都可以把信息传递给服务器，也能从服务器获取到结果，只不过是谁多谁少的问题
- GET:给的少，拿的多
- POST:给的多，拿的少

客户端怎么把信息传递给服务器?
- 问号传参    xhr.open('GET','/getdata?xxx=xxx&xxx=xxx')
- 设置请求头  xhr.setRequestHeader([key],[value])
- 设置请求主体  xhr.send(请求主体信息)

服务器怎么把信息返回给客户端？
- 通过响应头
- 通过响应主体（大部分信息都是基于响应主体返回的）

GET系列和POST系列的本质区别：
> GET系列传递给服务器信息的方式一般采用：问号传参
> POST系列传递给服务器信息的方式一般采用：设置请求主体

1. GET传递给服务器的内容比POST少，因为URL有最长大小限制（IE浏览器一般限制2KB，谷歌浏览器一般限制4~8KB，超过长度的部分自动被浏览器截取了）
```
xhr.open('GET','/list?name=zhufeng&year=10&xxx=xxx...')
xhr.send('....')  请求主体中传递的内容理论上没有大小限制，但是真实项目中，为了保证传输的速度，我们会自己限制一些
```

2. GET会产生缓存（缓存不是自己可控制的）：因为请求的地址（尤其是问号传递的信息一样），浏览器有时候会认为你要和上次请求的数据一样，拿的是上一次信息；这种缓存我们不期望有，我们期望的缓存是自己可控制的；所以真实项目中，如果一个地址，GET请求多次，我们要去除这个缓存；
```
//=>解决办法设置随机数
xhr.open('GET','/list?name=zhufeng&_='+Math.random());
...
xhr.open('GET','/list?name=zhufeng&_='+Math.random());
```

3. GET相比较POST来说不安全：GET是基于问号传参传递给服务器内容，有一种技术叫做URL劫持，这样别人可以获取或者篡改传递的信息；而POST基于请求主体传递信息，不容易被劫持；
