<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>DRAG-拖拽</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<style>
		html,
		body {
			height: 100%;
			overflow: hidden;
		}

		.box {
			position: absolute;
			top: 0;
			left: 0;
			width: 100px;
			height: 100px;
			background: red;
			cursor: move;
		}
	</style>
</head>

<body>
	<div class="box" id="box"></div>

	<script>
		box.addEventListener('mousedown', down);

		function down(ev) {
			this.startX = ev.pageX;
			this.startY = ev.pageY;
			this.startL = this.offsetLeft;
			this.startT = this.offsetTop;
			//=>把执行BIND处理后的函数存储到盒子的自定义属性上，绑定的时候绑定存储的这个方法，移除的时候也基于自定义属性获取到这个方法移除
			this._MOVE = move.bind(this);
			this._UP = up.bind(this);
			document.addEventListener('mousemove', this._MOVE);
			document.addEventListener('mouseup', this._UP);
		}

		function move(ev) {
			let curL = ev.pageX - this.startX + this.startL,
				curT = ev.pageY - this.startY + this.startT;
			let minL = 0,
				minT = 0,
				maxL = document.documentElement.clientWidth - this.offsetWidth,
				maxT = document.documentElement.clientHeight - this.offsetHeight;
			curL = curL < minL ? minL : (curL > maxL ? maxL : curL);
			curT = curT < minT ? minT : (curT > maxT ? maxT : curT);
			this.style.left = curL + 'px';
			this.style.top = curT + 'px';
		}

		function up(ev) {
			document.removeEventListener('mousemove', this._MOVE);
			document.removeEventListener('mouseup', this._UP);
		}
	</script>


	<script>
		/* box.onmousedown = down;

		function down(ev) {
			//=>把鼠标起始位置信息和盒子起始位置信息存储到盒子的自定义属性上
			this.startX = ev.pageX;
			this.startY = ev.pageY;
			this.startL = this.offsetLeft;
			this.startT = this.offsetTop;
			//=>按下来在给盒子绑定MOVE方法
			//=>谷歌浏览器中解决鼠标焦点丢失的问题（别绑定给盒子了，绑定给document），但是要注意move中的this已经是document了，而不是之前的box，我们需要处理一下
			document.onmousemove = move.bind(this);
			document.onmouseup = up.bind(this);
		}

		function move(ev) {
			//=>随时获取当前鼠标的信息，计算盒子最新的位置
			let curL = ev.pageX - this.startX + this.startL,
				curT = ev.pageY - this.startY + this.startT;
			//=>边界判断
			let minL = 0,
				minT = 0,
				maxL = document.documentElement.clientWidth - this.offsetWidth,
				maxT = document.documentElement.clientHeight - this.offsetHeight;
			curL = curL < minL ? minL : (curL > maxL ? maxL : curL);
			curT = curT < minT ? minT : (curT > maxT ? maxT : curT);
			this.style.left = curL + 'px';
			this.style.top = curT + 'px';
		}

		function up(ev) {
			//=>鼠标抬起，把MOVE移除掉
			document.onmousemove = null;
			document.onmouseup = null;
		}
 */

		/*
		 *  //=>把鼠标和当前盒子拿绳子捆在一起
			this.setCapture();
			//=>把鼠标和盒子解绑
			this.releaseCapture(); 
			=>谷歌不支持
		 */
	</script>
</body>

</html>