<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训</title>
	<link rel="stylesheet" href="css/reset.min.css">
	<style>
		html,
		body {
			height: 100%;
			background: lightcyan;
		}

		#box {
			box-sizing: border-box;
			position: absolute;
			top: 50%;
			left: 50%;
			margin: -100px 0 0 -100px;
			width: 200px;
			height: 200px;
			background: lightcoral;
		}
	</style>
</head>

<body>
	<div id="box"></div>

	<script src="js/jquery.min.js"></script>
	<script>
		let $box = $('#box'),
			box = $box.get(0);

		/*
		 * 给元素的事假行为绑定方法，当事件行为触发方法会被执行，不仅被执行，而且还会把当前操作的相关信息传递给这个函数 =>“事件对象”
		 * 如果是鼠标操作，获取的是MouseEvent类的实例 =>鼠标事件对象
		 *   鼠标事件对象 -> MouseEvent.prototype -> UIEvent.prototype -> Event.prototype -> Object.prototype
		 * 如果是键盘操作，获取的是KeyboardEvent类的实例 =>键盘事件对象
		 * 除了以上还有：普通事件对象(Event)、手指事件对象(TouchEvent)等
		 */

		/* box.onclick = function (ev) {
			//=>鼠标事件对象
			//clientX/clientY：当前鼠标触发点距离当前窗口左上角的X/Y轴坐标
			//pageX/pageY：触发点距离当前页面左上角的X/Y轴坐标
			//type：触发事件的类型
			//target：事件源（操作的是哪个元素，哪个元素就是事件源），在不兼容的浏览器中可以使用srcElement获取，也代表的是事件源
			//preventDefault()：用来阻止默认行为的方法，不兼容的浏览器中用ev.returnValue=false也可以阻止默认行为
			//stopPropagation()：阻止冒泡传播，不兼容的浏览器中用ev.cancelBubble=true也可以阻止默认行为
			console.log(ev);
		} */


		/* 事件对象和函数以及给谁绑定的事件没啥必然关系，它存储的是当前本次操作的相关信息，操作一次只能有一份信息，所以在哪个方法中获取的信息都是一样的；第二次操作，存储的信息会把上一次操作存储的信息替换掉...；
		 * 
		 * 每一次事件触发，浏览器都会这样处理一下
		 *   1.捕获到当前操作的行为（把操作信息获取到），通过创建MouseEvent等类的实例，得到事件对象EV
		 *   2.通知所有绑定的方法（符合执行条件的）开始执行，并且把EV当做实参传递给每个方法，所以在每个方法中得到的事件对象其实是一个
		 *   ......
		 *   3.后面再重新触发这个事件行为，会重新获取本次操作的信息，用新的信息替换老的信息，然后继续之前的步骤...
		 */
		/* let obj = null;
		box.addEventListener('click', function (ev) {
			console.log(ev);
			obj = ev;
		});
		box.addEventListener('click', function (ev) {
			console.log(ev === obj); //=>true
		});
		document.body.onclick = function (ev) {
			console.log(ev === obj); //=>true
		} */
	</script>
</body>

</html>