<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>回调函数-珠峰培训</title>
</head>

<body>
	<script>
		/*
		 * 把一个函数当做实参传递给另外一个函数，在另外一个函数执行的过程中，把传递进来的函数执行，这种机制就是回调函数 
		 * @真实场景应用
		 *    AJAX异步请求成功做什么事
		 *    浏览器内置的一些方法支持回调函数
		 *    插件组件封装中的钩子函数（生命周期函数）
		 *    ......
		 */
		/* new Drag('.box', {
			dragstart: function () {},
			dragmove: function () {},
			dragend: function () {}
		}); */

		/* let arr = [10, 20, 30];
		//=>forEach/sort/map/find/filter/some/every/reduce...
		arr.forEach((item, index) => {});
		setTimeout(() => {}, 1000); */

		/* function queryData(callback) {
			$.ajax({
				url: 'xxx.json',
				method: 'get',
				async: true,
				success: result => {
					typeof callback === 'function' ? callback(result) : null;
				}
			});
		}
		queryData(function anonymous(data) {
			//=>data:服务器返回的结果
		}); */

		/*
		 * 重写字符串内置方法replace 
		 *    1.正则在字符串中匹配几次，我们传递的回调函数就会被执行几次（前提：正则设置了global修饰符）
		 *    2.每一次执行回调函数，都把当前正则匹配的信息（既有大正则，也有小分组的）传递给回调函数
		 *    3.还要接收回调函数的返回值，返回的是啥内容，就要把当前字符串中正则匹配这一部分内容替换成啥
		 */
		/* ~ function () {
			//=>处理字符串：把字符串中的某一项替换成另外一项
			function handle(str, val1, val2) {
				let index = str.indexOf(val1);
				return str.substring(0, index) + val2 + str.substring(index + val1.length);
			}

			function replace(reg, callback) {
				let _this = this.substring(0),
					isGlobal = reg.global,
					arr = reg.exec(this);
				while (arr) {
					//=>捕获到的结果是数组(执行回调函数,把捕获的结果传递给它)；还要接收回调函数执行的返回值，用返回值替换字符串中当前正则匹配的内容；
					if (typeof callback === "function") {
						let res = callback.apply(null, arr);
						_this = handle(_this, arr[0], res);
					}
					arr = reg.exec(this);
					//=>不设置GLOBAL的情况执行一次
					if (!isGlobal) break;
				}
				return _this;
			}
			String.prototype.replace = replace;
		}();
		let str = "{0}年{1}月{2}日",
			arr = ['2019', '09', '03'];
		str = str.replace(/\{(\d)\}/g, function (content, group1) {
			return '@#' + arr[group1];
		});
		console.log(str); */
	</script>

	<script>
		var _obj = {
				isNumeric: "Number",
				isBoolean: 'Boolean',
				isString: 'String',
				isNull: 'Null',
				isUndefined: 'Undefined',
				isSymbol: 'Symbol',
				isPlainObject: 'Object',
				isArray: 'Array',
				isRegExp: 'RegExp',
				isDate: 'Date',
				isFunction: "Function",
				isWindow: 'Window'
			},
			_toString = _obj.toString,
			_type = {};
		for (var key in _obj) {
			if (!_obj.hasOwnProperty(key)) break;
			_type[key] = (function () {
				var reg = new RegExp("^\\[object " + _obj[key] + "\\]$");
				return function anonymous(val) {
					return reg.test(_toString.call(val));
				}
			})();
		}


		/*
		 * _each：遍历数组、类数组、对象中的每一项 
		 *   @params
		 *     obj:需要迭代的数组、类数组、普通对象
		 *     callback:回调函数（每遍历数组中的某一项，就会把回调函数执行一次；而且需要把当前遍历的内容和索引[属性值和属性名]传给回调函数；接收回调函数的返回结果，如果是false，则结束当前的循环，如果是其它值，让返回的值替换数组中的当前项，如果没有返回值，则什么都不处理...）
		 *     context:传递的第三个参数，可以改变回调函数中的THIS指向，不传递默认是window
		 *   @return
		 *     返回一个新的数组或者对象（原来的数组或者对象不变）
		 */
		function _each(obj, callback, context = window) {
			let isLikeArray = _type.isArray(obj) || (('length' in obj) && _type.isNumeric(obj.length));
			typeof callback !== "function" ? callback = Function.prototype : null;

			//=>数组或者类数组
			if (isLikeArray) {
				let arr = [...obj];
				for (let i = 0; i < arr.length; i++) {
					let item = arr[i],
						result = callback.call(context, item, i);
					if (result === false) break;
					if (typeof result === "undefined") continue;
					arr[i] = result;
				}
				return arr;
			}

			//=>对象的处理
			let opp = {
				...obj
			};
			for (let key in opp) {
				if (!opp.hasOwnProperty(key)) break;
				let value = opp[key],
					result = callback.call(context, value, key);
				if (result === false) break;
				if (typeof result === "undefined") continue;
				opp[key] = result;
			}
			return opp;
		}

		/* let obj = {
			name: '珠峰',
			year: 10,
			teacher: '哇咔咔~'
		};
		let obj2 = _each(obj, function (value, key) {
			// console.log(this); //=>document
			// console.log(value, key);
			if (key === "name") {
				return "珠峰培训@zhufeng";
			}
		}, document);
		console.log(obj, obj2); */

		/* function func() {
			let arr = _each(arguments, (item, index) => {
				console.log(item, index);
				if (index >= 2) return false;
				return item * 10;
			});
			console.log(arguments, arr);
		}
		func(10, 20, 30, 40); */
	</script>
</body>

</html>