### I/O
> I：input 输入
> O：output 输出
> I/O一般指对文件的读写操作

JS在客户端浏览器中运行，能否对客户端本地的文件进行读写操作？
> 答案：不能，因为要保证客户端的信息安全
> input:type='file' 文件上传这种除外，但是这种也需要用户手动选择后才可以

JS在服务器端运行（基于NODE运行），能否对服务器端的文件进行操作？
> 答案：可以的
> NODE赋予了JS进行I/O操作的能力（内置模块：fs）

### window & global
1. 在客户端浏览器中运行JS，JS全局对象是：window（提供了很多内置的属性和方法）

2. 在NODE中运行JS，全局对象是：global
- process ：node中进程管理的属性  
	+ process.nextTick()
	+ process.env NODE全局环境变量
- Buffer
- setImmediate 立即执行（类似于setTimeout(func,0)）

3. 在REPL命令中输出的this是global，但是在xxx.js中输出的this是当前模块本身


### 复习NPM
1. 模块管理（安装和卸载）
> 安装在全局环境下和安装在当前项目中
- 全装在全局：$ npm install xxx --global （$ npm i -g xxx）
- 安装在本地项目中：$ npm i xxx
	+ 把模块设置为开发依赖（开发中）：$ npm i xxx --save-dev
	+ 把模块设置为生产依赖（部署到服务器）：$ npm i xxx --save
- 安装在全局和本地的区别
	+ 安装在全局后对任何项目都有作用（也有可能导致版本冲突），但是只能基于命令的方式管理，不能基于CommonJS中的require导入使用（通俗说：就是不能导入到文件中基于代码来处理）
		+ $ npm root -g 查看全局安装到的目录
		+ 之所以可以使用命令操作，是因为在全局目录下生成了一个xxx.cmd的文件
	+ 安装在本地默认不能基于命令管理，但是可以导入到文件中基于代码操作，只对当前项目有用
- 在本地安装模块之前，最好先：$ npm init -y，生成package.json模块配置文件
	+ 把安装的模块生成配置清单，存放在package.json中，后期别人需要部署项目的时候，只需要执行 $ npm i 就可以把所有的依赖项重新安装一遍 “跑环境”
		+ $ npm i 是把开发和生产依赖都安装一遍
		+ $ npm i --production 只安装生产依赖的模块
	+ 在package.json中，可以基于scripts选项配置本地可执行的脚本命令 $npm run xxx
		```
		"scripts": {
			//=>AAA是命令，值是要做的事情
			"AAA": "node xxx.js"
		}
		```
	+ 在配置可执行脚本命令的时候，基于process的环境变量区分开发还是生产环境
		```
		"scripts": {
			//=>set NODE_EVN=dev 设置全局环境变量（MAC下用 export NODE_EVN=dev）
    		"serve": "set NODE_EVN=dev&&node test1.js",
   			"build": "set NODE_EVN=pro&&node test1.js"
  		}
		```

### CommonJS模块管理机制
> AMD：require.js
> CMD：sea.js
> CommonJS：node.js
> ES6 Module
> 这些模块化思想，规定了在JS中我们的模块该如何的创建、如何的导入以及如何导出

- 内置模块：NODE中自带的
	+ http/https 创建和管理服务的模块
	+ fs 给予JS进行I/O操作的
	+ url 解析URL地址的
	+ path 管理路径的
	+ ...
- 第三方模块：基于npm安装，别人写好供我们用的
	+ mime
	+ qs
	+ express
	+ express-session
	+ body-parser
	+ ...
- 自定义模块：自己写的模块

### NODE中的模块管理
1. 在NODE环境下，我们每创建一个JS，都相当于创建了一个新的模块；模块中的方法也都是模块的私有方法，不同模块之间的同名方法不会有任何的冲突；

2. module.exports就是NODE天生自带的用来导出模块中方法的方式
```
module.exports={
	//=>这些属性方法就是需要暴露给外面调取使用的
	xxx:xxx
};
```

3. require是NODE天生提供的用来导入模块的方法
```
//=>语法：
let [模块名] = require([模块的地址]);

//=>例如：
//1)可以省略.js后缀名
//2)如果是调取自己定义的模块，则需要加 /(根目录) ./(当前目录) ../(上级目录) 这三个中的某一个
//3)不加上述地址，则先找第三方模块（安装在自己本地的），如果没有安装，则找NODE中的内置模块，如果再没有，则报错
let A = require('./A');
let qs = require('qs');
```

4. require导入模块是同步的（没导入完成，后面的事情是不处理的）；每一次导入模块都是把导入的模块中的JS代码从上到下执行一遍（只执行一遍）；



=======================================
现在大家出现这种情况的原因：
1. 欠账太多了（之前的某些内容还有一些没有复习到或者研究透的）
+ 组件封装类的，不一定要把他彻底弄明白（自己写出来）
+ 对于这些，大家要做的是，有个思路，知道咋回事，看懂即可

2. 疲乏了（“身心俱疲”）
> 到一家公司第一年“雄心壮志”；第二年“平平淡淡”；第三年“想走”...
> 十月一回去后调整一下状态

3. 缺乏思考的方式（缺乏做事的方式）

4. 缺乏尝试勇气

现阶段学习的情况和“基础薄弱”、“学历低”等没有必然的关系，只和学习习惯和思维方式以及努力度有关系（有的同学开窍就会晚一些）

思考方式：
第一步：先想明白
1. 咋做
2. 代码大体上要做哪些事情
3. 拿笔和纸写出来

步骤1：点击编辑进入到增加页面，要在增加页知道点击的是谁，需要点击的时候把部门ID传递过去（问号传参）
步骤2：增加页面咋区分增加还是修改，哦，修改的时候传东西了，所以第一步我们要获取到传递的信息，有信息就是修改，没有就是新增
步骤3：如果是修改，我需要从服务器把信息拿回来，展示在对应的文本框中
步骤4：点击提交的时候，我们要区分增加还是修改，把信息传递给服务器，然后接收返回结果，进行对应的处理

========================================
有的同学还是太懒散
- 现在出去面试：技术为王