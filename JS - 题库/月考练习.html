<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        .box {
            width: 400px;
            height: 400px;
            border: 1px solid red;
            margin: auto;
            position: relative;

        }

        .box_1 {
            background: rebeccapurple;
            width: 100px;
            height: 100px;
            position: absolute;
            /* top:50%;
            left:50%;
            margin-top:-50px;
            margin-left:-50px; */
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            margin: auto;
        }
    </style>
</head>

<body>
    <div class="box">
        <div class="box_1"></div>
    </div>
</body>

</html>
<!-- <script>
    /*
1. JS中的数据类型都有哪些？它们之间有什么区别？该如何检测？
       ==> 基本数据类型：Number string boolen null undefined symbol
           引用数据类型：对象（ 数组对象 正则对象 普通对象）Function...
           区别：值类型==>主要操作值，存放在栈内存中，栈内存提供代码的运行环境
                引用数据类型==>主要操作地址，存放在堆内存中
                typeof xxx;
                constructor;
                object.prototype.toString.call(xxx);
                (xxx)instenceof ;
2. 常用浏览器的内核都有哪些？
    webkit(v8)大部分浏览器
    Gecko:火狐
    Tirdent：iE
3. 数组中常用的迭代方法有哪些？都是什么意思？（至少四种）
    //=>迭代方法：指的是能够对数组中的每一项进行遍历，例如forEach
    arr.forEach((item,index)=>{
    ...
    });
    arr.map((item,index)=>{
    return ...
    });
    forEach==>循环数组中每一项
    map ==> 循环每一项给的函数 返回值是函数调用每一项的值组成的数组
    for循环==>循环数组的每一项
    ===>es6新增
    for(let val of ary){  既有return 而且不会遍历数组的私有属性
        console.log(val)
    }
4.说一下你对闭包的理解，以及工作中什么地方你用到了闭包？
   ==>闭包是JS中一个重要的机制我们很多编程思想、业务逻辑、设计模式都是基于闭包完成的
          函数执行会形成一个私有作用域，而且这个作用域是不销毁的，保护私有作用域中得变量
          同时也把值保存了起来，这种机制就是闭包，通俗讲就是形成一个不销毁的私有作用域，
          在我们做项目当中尤其针对两个人模块化开发是时候，全局变量会收到污染，这是就需要
          用到闭包，在做一些选项卡的时候，循环点击也用到了闭包，因为for循环是同步，绑定
          事件是异步，同步就是我把当前所有的事做完才能进行下边的操作，异步是不用等可以接
          着进行下边的操作，这时给绑定时事件一个闭包，形成私有作用域，把循环的时候索引保存起来
5. 阐述一下let/var/const三者之间的区别？
   ==>  var、const 用来声明变量 const声明常量，var可以重复声明 let、const不可以，var 和let
        声明的变量 值可以改const是常量值不可以修改，let和const不存在变量提升，而且let可以识别
        块级作用域，存在暂时性死区，var和window存在映射机制，var一个变量window下回对应增加这个
        属性，而let回打断这种机制
6. 阐述一下call/apply/bind三者之间的区别，以及应用场景？
   ==>  三者都是用来改变函数中this指向,call/apply都是让函数立即执行，bind返回一个新函数，新函数
        执行让老函数执行并且 让老函数中得this指向改掉，call 后面传参是散乱的传 apply是以打包的形式传。
        场景==>可以基于call让类数组借用数组原型上的方法，例如（slice.call类数组转数组），
        基于apply可以实现最大值最小值，
        可以基于call实现继承
7.怎么让一个 div 水平垂直居中？（不少于三种解决方案）
*/
    //8. 写出下面代码的输出结果
    let result = 5 + true + null + [] + '北京珠峰培训' + undefined + false + { name: "哇咔咔~" };
    console.log(result);//'6北京珠峰培训undefinedNaN[object object]'
    //9. 写出下面代码的输出结果
    let res = Number('200px');
    if (res === 200) {
        alert(200);
    } else if (res === NaN) {
        alert(NaN);
    } else if (typeof res === 'number') {
        alert('number');
    } else {
        alert('Invalid Number');
    }
     //'number'
    //10. 写出下面代码输出结果
    var a = 10,
        b = 20;
    function func(a) {
        console.log(a, b);//10 20
        a = b = 13;
        console.log(a, b);//13 13
    }
    func(a);
    console.log(a, b);//10 13
    //11. 写出下面代码输出的结果
    var x = 5;
    function func(z) {
        return function (y) {
            console.log(y - (x++));
        }
    }
    var f = func(10);
    f(1);//-4
    func(2)(4);//-2
    f(3);//-4
    console.log(x);//8
    //12. 写出下面代码输出结果
    var x = 2, y = 3;
    function func() {
        x *= y;
        func = function (y) {
            console.log(y + (--x));
        };
        console.log(x, y);
    }
    func(5);//6 3
    func(5);//10
    console.log(x, y);//5 3


    //13.写出下面代码输出结果
    let obj = {
        0: 3,
        1: 4,
        length: 2,
        unshift: Array.prototype.unshift
    }
    obj.unshift(1);
    obj.unshift(2);
    console.log(obj);
    /* let obj = {
    0: 2,
    1: 1,
    2: 3,
    3: 4
    length: 4,
    unshift: Array.prototype.unshift
} */
    // 14. 写出下面代码输出结果 
    /* var x = 5;
     var obj = { x: 10 };
    obj.fn = (function () {
        this.x += --x;
        return function (y) {
            this.x += (--x) + y;
            console.log(x);
        }
    })();
    var fn = obj.fn;
    obj.fn(5);//8
    fn(10);//25
    console.log(obj.x, x); //23 25 */
    //15
    //example 1
    let a = {}, b = '0', c = 0;
    a[b] = '珠峰';
    a[c] = '培训';
    console.log(a[b]);
    //---------------------
    //example 2
    let a = {}, b = Symbol('1'), c = Symbol('1');
    a[b] = '珠峰';
    a[c] = '培训';
    console.log(a[b]);
    //---------------------
    //example 3
    let a = {}, b = { n: '1' }, c = { m: '2' };
    a[b] = '珠峰';
    a[c] = '培训';
    console.log(a[b]);
    //16. 写出下面代码的运行结果
    function Fn() {
        this.x = 10;
        this.y = 20;
        this.getX = function () {
            console.log(this.x);
        }
    }
    Fn.prototype = {
        x: 30,
        y: 40,
        getY: function () {
            this.y += 1;
            console.log(this.y);
        },
        sum: function () {
            console.log(this.x + this.y);
        }
    };
    let f1 = new Fn;
    let f2 = new Fn;
    console.log(f1.getX === f2.getX);//false
    console.log(f1.getY === f2.getY);//true
    console.log(f1.constructor);//object
    f2.getX();//10
    f1.__proto__.getY();//41
    Fn.prototype.sum();//71
    //17 写出下面代码的运行结果
    var name = '珠峰培训';
    function A(x, y) {
        var res = x - y;
        console.log(res, this.name);
    }
    function B(x, y) {
        var res = x + y;

        console.log(res, this.name);
    }
    A.call(B, 1, 2);//-1 B
    A.call.call(B, 1, 2);//NaN undefeined
    Function.prototype.call(B, 1, 2);//空的自执行函数
    Function.prototype.call.call(B, 1, 2);//NaN undefined
    //18 写出下面代码的运行结果
    function Func() {
        A = function () {
            alert(1);
        };
        return this;
    }
    Func.A = A;
    Func.prototype = {
        A: () => {
            alert(2);
        }
    };
    function A() {
        alert(3); 
    }
    A();//3
    Func.A();//3
    Func().A();//1
    new Func.A();//3
    new Func().A();//2
    new new Func().A();//2
    //19 写出下面代码的运行结果
    function A1(name) {
        name && (this.name = name);
    }
    function A2(name) {
        this.name = name;
    }
    function A3(name) {
        this.name = name || 'Jerry';
    }
    A1.prototype.name = 'Tom';
    A2.prototype.name = 'Tom';
    A3.prototype.name = 'Tom';
    alert((new A1().name) + (new A2().name) + (new A3().name));//'TomundefinedJerry'
</script> -->

<script>
    // var box = document.querySelector('#box'),
    //     btnList = document.querySelectorAll('button'),
    //     colorAry = ['red', 'green', 'blue'];

    // for (var i = 0; i < btnList.length; i++) {
    //    
//          function fn(n){
   //       return function(){
    //      box.style.background = colorAry[n];
   //       }
     //   btnList[n].onclick =fn(i);
    /*
* 1.编写一个方法“flatten”，将数组扁平化 （至少两种办法）
* 2.然后实现“unique”数组去重方法，把数组进行去重 （至少两种办法）
*/
    //方法一:
    // Array.prototype.flatten = function () {
    //     let res = JSON.stringify(this);
    //     let res1 = res.replace(/(\[|\])+/g, '');
    //     res2 = '[' + res1 + ']';
    //     let _this = this
    //     _this = JSON.parse(res2)
    //     return _this
    // }
    // Array.prototype.unique = function () {
    //     let obj = {};
    //     for (let i = 0; i < this.length; i++) {
    //         let temp = this[i];
    //         if (obj.hasOwnProperty(temp)) {
    //             this.splice(i, 1);
    //             i--;
    //         }
    //         obj[temp] = temp;
    //     }
    //     return this
    // }
    // let ary = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
    // console.log(ary.flatten().unique().sort((a, b) => a - b));
    // ary.flatten().unique().sort((a, b) => a - b); //=>[1, 2, 3, 4, 5,6, 7, 8, 9....]
    // // 方法二：
    // //     Array.prototype.flatten = function () {
    // //         let res = this.flat(infinity)
    // //         return res;
    // //     }
    // //     Array.prototype.unique = function () {
    // //         for (let i = 0; i < this.length; i++) {
    // //             let temp = this[i];
    // //             for (let j = i + 1; j < this.length; j++) {
    // //                 let item = this[j];
    // //                 if (temp === item) {
    // //                     this.splice(j, 1);
    // //                     j--
    // //                 }
    // //             }
    // //         }
    // //         return this;
    // //     }
    // //     let ary = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
    // //    console.log(ary.flatten().unique().sort((a, b) => a - b));
    // //     ary.flatten().unique().sort((a, b) => a - b); //=>[1, 2, 3, 4, 5,6, 7, 8, 9....]
    // function Dog(name) {
    //     this.name = name;
    // }
    // Dog.prototype = {
    //     bark() {
    //         console.log('wangwang');
    //     },
    //     sayName() {
    //         console.log('my name is ' + this.name);
    //     }
    // };
    // function _new(...arg) {
    //     //  ...arg  就相当于  Person,name,age
    //     var obj = {};
    //     var Constructor = arg.shift();
    //     // 把obj.__proto__指向Constructor的原型
    //     obj.__proto__ = Constructor.prototype;
    //     // res就是引用数据类型
    //     var res = Constructor.call(obj, ...arg);
    //     return typeof res === 'object' ? res : obj;
    // }
    // Function.prototype._new = _new;
    // let sanmao = _new(Dog, '三毛');
    // sanmao.bark(); //=>"wangwang"
    // sanmao.sayName(); //=>"my name is 三毛"
    // console.log(sanmao instanceof Dog); //=>true 


    // ~function () {
    //     function change(context, ...arg) {
    //         var context = context || window;
    //         var n = Symbol();//Symbol执行达到为一的随机数
    //         context[n] = this;
    //         let res = context[n](...arg);
    //         delete context[n];
    //         return res;
    //     };
    //     Function.prototype.change = change;
    // }();
    // let obj = { name: 'zhufeng' };
    // function func(x, y) {
    //     this.total = x + y;
    //     return this;
    // }
    // let res = func.change(obj, 100, 200);
    // //res => {name:'Alibaba',total:300}
    // console.log(res);




    /*  var obj = {
         name: '小年',
         skill: ['css3', 'HTML5', 'es6', 'react'],
         say: function () {
             for (let i = 0; i < this.skill.length; i++) {
                 setTimeout(() => {
                     console.log(`${this.name}会${this.skill[i]}`)
                 }, 1000 * (i + 1))
             }
         }
     } */
    // obj.say();
    // function Person(name, skill) {
    //     this.name = name;
    //     this.skill = skill;
    // }
    // Person.prototype.say = function () {
    //     for (let i = 0; i < this.skill.length; i++) {
    //         setTimeout(() => {
    //             console.log(`${this.name}会${this.skill[i]}`)
    //         }, 1000 * (i + 1))
    //     }
    // }
    // var p = new Person('晓明', ['css', 'html', 'react', 'angular']);
    // p.say();

    // class Person {
    //     constructor(name, skill) {
    //         this.name = name;
    //         this.skill = skill;
    //     }
    //     say() {
    //         for (let i = 0; i < this.skill.length; i++) {
    //             setTimeout(() => {
    //                 console.log(`${this.name}会${this.skill[i]}`)
    //             }, 1000 * (i + 1))
    //         }
    //     }
    // }
    // var p = new Person('晓明', ['css', 'html', 'react', 'angular']);
    // p.say();/
</script>